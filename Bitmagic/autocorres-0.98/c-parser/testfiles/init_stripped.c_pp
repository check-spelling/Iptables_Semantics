typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned long uint32_t;

typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int32_t;

typedef uint32_t paddr_t;
typedef uint32_t word_t;

struct free_block {
    paddr_t base;
    paddr_t top;
};
typedef struct free_block free_block_t;

struct free_list {
    free_block_t block;
    struct free_list* next;
};
typedef struct free_list free_list_t;

struct region {
    paddr_t base;
    unsigned int size_bits;
};
typedef struct region region_t;

struct region_list {
    unsigned int count;
    const region_t *entries;
};
typedef struct region_list region_list_t;

static uint8_t initHeap[(2 * (1 << 12))] __attribute__((__section__(".init.data")));
static void* initHeapPtr __attribute__((__section__(".init.data")));

static __attribute__((__section__(".init"))) void* malloc_boot(word_t alloc_size) {
    void* result;
    uint8_t* new_heap_ptr;

    if(!initHeapPtr) initHeapPtr = (void*)initHeap;

    new_heap_ptr = (uint8_t*)initHeapPtr + alloc_size;
    if(new_heap_ptr >= &initHeap[(2 * (1 << 12))]) {
        return ((void *)0);
    }

    result = initHeapPtr;
    initHeapPtr = (void*)new_heap_ptr;

    return result;
}

static __attribute__((__section__(".init"))) free_list_t*
free_list_remove_regions(const region_list_t* regions,
        free_list_t* from_free_list)
{
    unsigned int i;
    free_list_t* node = from_free_list;

    for(i = 0; i < regions->count; i++) {
        paddr_t rbase, rtop;
        paddr_t fbase = 0, ftop = 0;
        free_list_t *high;

        rbase = regions->entries[i].base;
        rtop = rbase + (1<<(regions->entries[i].size_bits)) - 1;

        for(; node; node = node->next) {
            fbase = node->block.base;
            ftop = node->block.top;
            if(ftop >= rbase) break;
        }



        ;
        ;
        ;

        if(rbase > fbase && rtop < ftop) {
            high = malloc_boot(sizeof(free_list_t));
            high->next = node->next;
            high->block.top = node->block.top;
            node->next = high;
        } else {
            high = node;
        }

        if(rbase > fbase) {
            node->block.top = rbase - 1;
        }
        if(rtop < ftop) {
            high->block.base = rtop + 1;
        }
        if(rbase == fbase && rtop == ftop) {
            *node = *node->next;
        }
    }

    return from_free_list;
}
