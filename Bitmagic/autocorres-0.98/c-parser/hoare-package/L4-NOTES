If you want to have "modifies" and "spec" assertions from your C
source picked up, you have to set up goal triples in your Isabelle
theory file with CALL if there is a function call at the top-level in
the triple.  (This may be an error in the parse translation code, as
it appears to conflict with at least some of Norbert's documentation.)

However, spec statements in the C file should be with PROC!  Perhaps
the safest way of stating the desired goal is by writing

  Call foo_'proc

where foo is the name of the function in the C sources.

You also need to make sure that you are including the appropriate
locales of course (things like "f_spec" and "f_modifies").

The big question is: how do you show a modifies specification to be
true?  In particular, it would be nice if we could prove something
like

"\<forall> \<sigma>.
       {\<sigma>}
       PROC foo_ptr_new(\<acute>foo_ptr, \<acute>bar)
       {t. t may_only_modify_globals s in [t_hrs]}"

without having to worry about guards.

The way to do this is use the \<^bsub>/UNIV\<^esub> annotation on the
turnstile, and the

  apply (vcg spec=modifies)

tactic.  The use of spec=modifies has two benefits

 * when the vcg tactic goes looking for specification
   assumptions/results to use, it will look for those with the suffix
   "_modifies".

 * it will apply the right simplification tactics to the
   may_only_modify_globals guff.  If you just do a vcg tactic, then
   you have to manually discharge these (though this is easy enough
   "simp add: mex_def meq_def" does it).

----------------------------------------------------------------------

Structure of a modifies term

If the concrete syntax is

  Γ ⊢/UNIV {σ}
              'ret__int :== PROC g()
            {t. t may_only_modify_globals σ in [var1, var2]}

then, the actual underlying term will be

ALL σ : state.
  HoarePartialDef.hoarep
    Γ
    {} : set of
           pair of [state, pair of [Int, pair of [state, state]]]
    UNIV : CProof.c_errortype set
    {σ} : set of state
    (Language.com.Call g_'proc)
    (Collect
       (λt:state.
          Hoare.mex : (var1's type => bool) => bool
            (λvar1 : var1's type.
               Hoare.mex : (var2's type => bool) => bool.
                 (λvar2 : var2's type.
                     Hoare.meq : globals => globals => bool
                        (StateSpace.state.globals t)
                        (var2_update
                           (λ _. var2)
                           (var1_update
                              (λ _. var1)
                              (StateSpace.state.globals σ))))))
    {} : set of state

Hoare.mex is equivalent to an existential quantifier.  Hoare.meq is
the same as equality.  Therefore, the post-condition for the above is
the set of states t such that there is a var1 and var2 value which when
put onto the original state σ give you t.

The longer the list of variables that are modified, the deeper the
nesting of the argument to Collect.

----------------------------------------------------------------------

Proving modifies results for mutually recursive functions

First figure out the size of the mutually recursive component.  Then
generate a custom rule for all the modifies statements at once.  If
there are n functions, then use

  HoarePackage.gen_proc_rec HoarePackage.Partial n

Call this thm.  Then state a goal that consists of the n modifies
statements conjoined together.  The first tactic that needs to be
applied is

  hoare_rule thm

Each conjunct then turns into a nice sub-goal that can be solved with

  vcg spec=modifies


