import sys
import re
import collections

from lib.relib import *
from lib.util import notice, error
from lib.firewall import *

import unittest

class ParseError(Exception):
    pass


iptables_format = {
    "Ln":  { 'std_chain_hdr': re.compile(r"""^Chain (\w+) \(policy ((?:ACCEPT|DROP))\)$"""),
             'custom_chain_hdr': re.compile(r"""^Chain ([\w\-~]+) \(\d+ references\)$"""),
             'chain_hdrdesc': re.compile(r"""^target (\ +) prot opt source (\ +) destination$"""),
             'rule': re.compile(r"""^
                        (?P<action>[\w\-~]+)?        #action, may be empty
                        \ *                     #spaces
                        (?P<proto>(?:\w\w\w\w?)|(?:\d\d)|(?:\d))    # 3-4 char proto, tcp,udp,esp,sctp,... or some strange number
                        \ ? \ ? \ ? \ (?P<opt>-[f-]) \ \ ?        #opt, usually just -- sometimes the f flag tells about ip fragments
                        (?P<ipsrc>!?"""+reIPv4Netmask+r""")  # ip src including /xx An ip address might be negated with a !
                        \ +
                        (?P<ipdst>!?"""+reIPv4Netmask+r""")
                        (?P<extra>\ [\w \*\!\./:%,\[\]\-"]+)?   # any extra options, please strip leading whitespaces
                        $""", re.X)
           },
    "Lnv": { 'std_chain_hdr': re.compile(r"""^Chain (\w+) \(policy ((?:ACCEPT|DROP)) \d+.? packets, \d+.? bytes\)$"""),
             'custom_chain_hdr': re.compile(r"""^Chain ([\w\-~]+) \(\d+ references\)$"""),
             'chain_hdrdesc': re.compile(r"""^\ *pkts\ +bytes\ +target \ + prot\ +opt\ +in\ +out \ * source (\ +) destination$"""),
             'rule': re.compile(r"""^
                        \ *\d+\w?      #pkts
                        \ +\d+\w?      #bytes
                        \ +
                        (?P<action>[\w\-~]+)?        #action, may be empty
                        \ *                     #spaces
                        (?P<proto>(?:\w\w\w\w?)|(?:\d\d)|(?:\d))    # 3-4 char proto, tcp,udp,esp,sctp,... or some strange number
                        \ ? \ ? \ ? \ (?P<opt>-[f-]) \ \ ?
                        (?P<iniface>"""+reIFACE+""") \ \ *
                        (?P<outiface>"""+reIFACE+""") \ \ *
                        (?P<ipsrc>!?"""+reIPv4Netmask+r""")  # ip src including /xx An ip address might be negated with a !
                        \ +
                        (?P<ipdst>!?"""+reIPv4Netmask+r""")
                        (?P<extra>\ [\w \*\!\./:%,\[\]\-"]+)?   # any extra options, please strip leading whitespaces
                        $""", re.X)
           }

}

def guess_format_by_std_hdr_line(line):
    """Parses the header of a default chain"""

    for dumpformat in iptables_format.keys():
        if re.match(iptables_format[dumpformat]['std_chain_hdr'], line):
            return dumpformat

    print("line: `{}'".format(line))
    print("Could not parse chain header. Was the input generated by `iptables -L -n' or `iptables -L -n -v'?")
    raise ParseError

def parse_std_chain_hdr(line, dumpformat):
    """Parses the header of a default chain"""

    assert dumpformat in iptables_format.keys()
    reChainHdr = iptables_format[dumpformat]['std_chain_hdr']

    m = re.match(reChainHdr, line)
    if not m:
        print("line: `{}'".format(line))
        print("dumpformat:{}".format(dumpformat))
        print("Could not parse chain header. Was the input generated by `iptables -L -n' or `iptables -L -n -v'?")
        raise ParseError

    return (m.group(1), m.group(2))

def parse_custom_chain_hdr(line, dumpformat):
    """Parses the header of a custom chain"""

    reChainHdr = iptables_format[dumpformat]['custom_chain_hdr']
    m = re.match(reChainHdr, line)
    if not m:
        print("parse_custom_chain_hdr: invalid header: `%s'" % line)
        raise ParseError

    return m.group(1)

def check_chain_hdrdesc(line, dumpformat):
    """Checks the 'table header' of a chain"""

    line = line.strip()
    r = iptables_format[dumpformat]['chain_hdrdesc']
    m = re.match(r, line)
    if not m: raise ParseError

    return m

def parse_ip(ip):
    r = re.compile(r"""^
        (?P<not>!)?                 # NOT
        (?P<ip>"""+reIPv4+r""")  # ip
        (?:/(?P<bitmask>\d\d?))?
        $""", re.X)
    m = re.match(r, ip)

    if not m or not m.group('ip'): raise ParseError
    
    parts = m.group('ip').split('.')
    if len(parts) != 4: raise ParseError

    if m.group('bitmask'):
        bitmask = int(m.group('bitmask'))
    else:
        bitmask = None

    invert = bool(m.group('not'))

    return IP(parts, bitmask, invert)

def parse_proto(proto):
    mapping = {
        'tcp': Known_Proto.tcp,
        'udp': Known_Proto.udp,
        'all': Known_Proto.all
    }

    return mapping[proto] if proto in mapping else Unknown_Proto(proto)

def parse_action(action):
    if action is None:
        return Std_Action.empty

    if ' ' in action: raise ParseError

    mapping = {
        'ACCEPT': Std_Action.accept,
        'DROP': Std_Action.drop,
        'LOG': Std_Action.log,
        'REJECT': Std_Action.reject,
        'QUEUE': Std_Action.unknown,
        'RETURN': Std_Action.ret
    }

    # could as well be a call to a custom chain, but we don't know yet
    return mapping[action] if action in mapping else Custom_Action(action)


def parse_extra(rule):
    """parses the right side of an `iptables -L -n' format (everything after destination). Argument: a Rule"""
    
    extra = rule.extra
    if extra is None:
        return rule
        
    """
    try to parse ports
    side-effect-free function
    Parameters:
        d - d for dst and s for src
        extra - the string of unparsed extra option
        proto (optional) - the protocol which was parsed
                           Use case: "tcp dpt:22" is submitted, if the parsed protocol is already tcp, we can ignore the tcp specification here
        
    """
    def parse_ports(d, extra, proto=None):
        assert(d == 'd' or d == 's')
        
        #only work with protocols we know for sure, don't touch the rest
        if not proto in [Known_Proto.tcp, Known_Proto.udp]:
            proto = None
        
        """before the ports are specified, sometimes the protocol is written again"""
        def check_protocol(parsed_protocol):
            if parsed_protocol is not None:
                #print("found protocol `%s' should correspond to previously parsed `%s'" % (m.group('protocol'), proto))
                assert(parse_proto(m.group('protocol')) == proto)
        
        #list of tuples [(star,end), (start,end)]
        ports = []
        
        # dpt:22
        # or "tcp dpt:22" or "udp dpt:22" but only if it corresponds to the supplied proto
        p = re.compile(r'(?P<protocol>(?:tcp|udp))? ?'+d+r'pt:(?P<port>\d+)')
        m = p.search(extra)
        if m is not None:
            check_protocol(m.group('protocol'))
            ports.append((m.group('port'), m.group('port')))
            extra = nonmatching_rest(m, extra)
        assert(p.search(extra) is None) # only one dpt can be specified
        
        #dpts:1:65535
        p = re.compile(r'(?P<protocol>(?:tcp|udp))? ?'+d+r'pts:(?P<port_start>\d+):(?P<port_end>\d+)')
        m = p.search(extra)
        if m is not None:
            check_protocol(m.group('protocol'))
            ports.append((m.group('port_start'), m.group('port_end')))
            extra = nonmatching_rest(m, extra)
        assert(p.search(extra) is None) # only one dpt can be specified
        
        #multiport dports 4569,5000:65535
        p = re.compile(r'multiport '+d+r'ports (?P<multiports>[0-9,:]*\d)')
        m = p.search(extra)
        if m is not None:
            multiports = m.group('multiports').split(',')
            for pts in multiports:
                ptssplit = pts.split(':')
                if len(ptssplit) == 1:
                    ports.append((ptssplit[0], ptssplit[0]))
                else:
                    assert(len(ptssplit) == 2)
                    ports.append((ptssplit[0], ptssplit[1]))
            extra = nonmatching_rest(m, extra)
        assert(p.search(extra) is None) # only one dpt can be specified

        ports = [(int(start), int(end)) for (start, end) in ports]
        for (start, end) in ports:
            assert(type(start) == type(0))
            assert(start <= end)
        return (extra, ports)
    
    (extra, dports) = parse_ports('d', extra, rule.proto)
    if dports:
        rule.dports = DPorts(dports)
    (extra, sports) = parse_ports('s', extra, rule.proto)
    if sports:
        rule.sports = SPorts(sports)
    
    rule.extra = extra
    
    return rule

def parse_rule(line, parse_ports, dumpformat):
    """Parses a single rule"""
    if line == "" or line == '\n':
        return None
    
    r = iptables_format[dumpformat]['rule']
    m = re.match(r, line)
    if not m:
        raise ParseError
    
    extra = m.group('extra')
    if extra:
        extra = m.group('extra').strip()
        if extra is "":
            extra = None

    opt = m.group('opt')
    if opt == "--":
        opt = None

    if extra is not None and opt is not None:
        extra = extra + " opt-flags: " + opt
    elif opt is not None: #extra is none
        extra = "opt-flags: opt"

    action = parse_action(m.group('action'))
    proto = parse_proto(m.group('proto'))
    ipsrc = parse_ip(m.group('ipsrc'))
    ipdst = parse_ip(m.group('ipdst'))

    rule = Rule(action, proto, ipsrc, ipdst, extra)


    # this format mus always have interfaces set!
    if dumpformat == "Lnv":
        assert 'iniface' in m.groupdict().keys()
        assert 'outiface' in m.groupdict().keys()
        rule.iniface = In_Iface(m.group('iniface'))
        rule.outiface = Out_Iface(m.group('outiface'))

    if parse_ports:
        return parse_extra(rule)
    else:
        return rule

def parse_rules(fd, parse_ports, dumpformat):
    """Parses a list of rules until an empty line is reached"""

    result = []
    while True:
        line = fd.readline()
        line = line.strip()
        if not line:
            break
        try:
            rule = parse_rule(line, parse_ports, dumpformat)
        except (ParseError, AssertionError):
            error("Parsing rule `{0}' failed".format(line))
            raise
        result.append(rule)
    return result

def parse_std_chain(fd, name, parse_ports):
    """Parses a single complete standard chain; namely INPUT, OUTPUT, FORWARD"""

    line = fd.readline()
    dumpformat = guess_format_by_std_hdr_line(line)
    (name0, policy) = parse_std_chain_hdr(line, dumpformat)

    assert name == name0
    
    line = fd.readline()
    check_chain_hdrdesc(line, dumpformat)
    
    rules = parse_rules(fd, parse_ports, dumpformat)
    return (dumpformat, policy, rules)

def parse_custom_chain(fd, parse_ports, dumpformat):
    """Parses a single complete custom chain; returns None if the input file is exhausted"""

    line = fd.readline()
    line = line.strip()
    if not line:
        return None

    chain = parse_custom_chain_hdr(line, dumpformat)
    assert chain != ""
    
    line = fd.readline()
    check_chain_hdrdesc(line, dumpformat)
    
    rules = parse_rules(fd, parse_ports, dumpformat)
    return (chain, rules)

def parse_firewall(filename, parse_ports=False):
    std_chains = collections.OrderedDict()
    custom_chains = collections.OrderedDict()

    dumpformat = None
    
    with open(filename, 'r') as fd:
        for chain in Firewall.std_chain_names:
            (dumpformat2, policy, rules) = parse_std_chain(fd, chain, parse_ports)
            if dumpformat is None:
                dumpformat = dumpformat2
            else:
                assert dumpformat == dumpformat2
            std_chains[chain] = Std_Chain(policy = parse_action(policy), rules = rules)

        while True:
            res = parse_custom_chain(fd, parse_ports, dumpformat)
            if not res:
                break
            (chain, rules) = res
            custom_chains[chain] = rules

    firewall = Firewall(std_chains = std_chains, custom_chains = custom_chains)
    count = sum([len(chain.rules) for chain in std_chains.values()]) + sum([len(chain) for chain in custom_chains.values()])

    notice("Parsed {0} rules".format(count))

    return firewall


